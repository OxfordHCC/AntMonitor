/*
 *  This file is part of AntMonitor <https://athinagroup.eng.uci.edu/projects/antmonitor/>.
 *  Copyright (C) 2018 Anastasia Shuba and the UCI Networking Group
 *  <https://athinagroup.eng.uci.edu>, University of California, Irvine.
 *
 *  AntMonitor is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  AntMonitor is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with AntMonitor. If not, see <http://www.gnu.org/licenses/>.
 */
package edu.uci.calit2.antmonitor.lib.vpn;

import android.content.Context;
import android.content.SharedPreferences;
import android.net.VpnService;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.ParcelFileDescriptor;
import android.util.Log;

import java.io.IOException;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.CancelledKeyException;
import java.nio.channels.Channel;
import java.nio.channels.ClosedChannelException;
import java.nio.channels.DatagramChannel;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.SocketChannel;
import java.nio.channels.spi.SelectorProvider;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.LinkedBlockingQueue;

import edu.uci.calit2.antmonitor.lib.logging.PacketAnnotation;
import edu.uci.calit2.antmonitor.lib.logging.PacketLogQueue;
import edu.uci.calit2.antmonitor.lib.util.IpDatagram;
import edu.uci.calit2.antmonitor.lib.util.PacketDumpInfo;
import edu.uci.calit2.antmonitor.lib.util.TCPPacket;
import edu.uci.calit2.antmonitor.lib.util.TCPReassemblyInfo;
import edu.uci.calit2.antmonitor.lib.util.UDPPacket;
import edu.uci.calit2.antmonitor.lib.vpn.VPNUtils.ChangeRequest;
import edu.uci.calit2.antmonitor.lib.vpn.VPNUtils.DataWriteToNet;
import edu.uci.calit2.antmonitor.lib.vpn.VPNUtils.TCPState;
import edu.uci.calit2.antmonitor.lib.vpn.VPNUtils.Tuple;


/**
 * The ForwarderManager is implemented using singleton pattern: 
 * there must be only a single instance exist for the VPN service.
 * <br>
 * The ForwarderManager is in charge of
 *
 * <p>
 * <b>UDP Forwarding</b>:
 * <ul>
 *     <li> (i) sending UDP packet by
 *         <ul>
 *             <li>opening protected UDP sockets</li>
 *             <li>translating and sending UDP packets</li>
 *         </ul>
 *     </li>
 *
 *     <li>
 *         (ii) receiving UDP packet
 *         <ul>
 *             <li>reading UDP packets from sockets</li>
 *             <li>translating UDP packets</li>
 *             <li>write back to TUN by forwarding the translated packets to the packet processor</li>
 *         </ul>
 *     </li>
 * </ul>
 *</p>
 *
 * <p>
 * <b>TCP Forwarding</b>:
 * <ul>
 *     <li>create one TCPForwarder for each TCP connection opened by the application</li>
 *     <li>forward data between application and server</li>
 * </ul>
 *</p>
 *
 * <p>
 * Number of threads: 3
 * <ul>
 *     <li>
 *         mSelectorNetIOThread: the main thread that performs polling of network IO.
 *          It switches between writing/reading data to/from the net (Java socket).
 *          Read data is queued and is later written to TUN by a separate thread.
 *      </li>
 *
 *      <li>
 *          mWriteToNetThread: reads packets from TUN (generated by the apps) and queues the data to be
 *          written by mSelectorNetIOThread at a later time.
 *      </li>
 *
 *      <li>
 *          mForwarderBacklogHandlerThread: a utility thread used to schedule events in a future time.
 *          This is handy to delay the closing of a TCP connection.
 *      </li>
 * </ul>
 * </p>
 *
 * <p>
 *     To begin forwarding, simply call <b>start(fd)</b>, where fd is the file descriptor of a TUN
 *     interface established by a {@link android.net.VpnService}. <br>
 *
 *     To stop forwarding and stop all threads, call <b>shutdown()</b>.
 * </p>
 *
 * @author Anh Le, Anastasia Shuba
 */
public class ForwarderManager {

    private static final String TAG = ForwarderManager.class.getSimpleName();
    static final boolean mVerboseLogging = false;
    
    static class Logg {
        public static void d(String tag, String msg) { if (mVerboseLogging) Log.d(tag, msg); }
        public static void i(String tag, String msg) { if (mVerboseLogging) Log.i(tag, msg); }
        public static void v(String tag, String msg) { if (mVerboseLogging) Log.v(tag, msg); }
        public static void w(String tag, String msg) { if (mVerboseLogging) Log.w(tag, msg); }
        public static void e(String tag, String msg) { if (mVerboseLogging) Log.e(tag, msg); }
        public static void e(String tag, String msg, Throwable t) {
            if (mVerboseLogging) Log.e(tag, msg, t);
        }
    }

    // These are the 3 threads (described above) of this ForwarderManager
    /** The main thread that performs polling of network IO.
     *  It switches between writing/reading data to/from the net (Java socket).
     *  Read data is queued and is later written to TUN by a separate thread. */
    private static Thread mSelectorNetIOThread;

    /** reads packets from TUN (generated by the apps) and queues the data to be
     *          written by mSelectorNetIOThread at a later time. */
    private static Thread mWriteToNetThread;

    /** a utility thread used to schedule events in a future time.
     *          This is handy to delay the closing of a TCP connection. */
    private static HandlerThread mForwarderBacklogHandlerThread;

    /** Handler used by mForwarderBacklogHandlerThread */
    static Handler mForwarderBacklogHandler;

    /** A utility thread used to schedule TLS connections on a separate thread so that the
     * regular networking thread is not delayed by heavy TLS operations. */
    private static HandlerThread mTLSHandlerThread;

    /** Handler used to attempt connections to {@link TLSProxyServer} */
    static Handler mTLSHandler;

    static boolean SSL_BUMPING_ENABLED = false;
    static boolean SSL_SNI_ENABLED = true;
    static boolean KEEP_DNS_CACHE = false;

    /** The VPN service responsible for establishing the VPN tunnel */
    static VpnClient mService;

    /** The signleton instance of ForwarderManager */
    private static ForwarderManager mSingleton = new ForwarderManager();

    /** Keeps state of the Forwarder */
    private boolean isRunning = false;

    /** Used to indicate no interest ops to prevent selector from spinning */
    private static final int OP_NONE = 0;

    // Used by SelectNetWorkIO Thread that perform Socket read/write with NIO
    private static final int SOCKET_BYTEBUFFER_READ_SIZE = 1024 * 16; // in bytes

    /** Size (in bytes) of the buffer used for writing packets to NET. Should be bigger than TUN SIZE */
    public static final int SOCKET_BYTEBUFFER_WRITE_SIZE = 1024 * 16;
    private static ByteBuffer mReadSocketBuffer = ByteBuffer.allocateDirect(SOCKET_BYTEBUFFER_READ_SIZE);
    private static ByteBuffer mWriteSocketBuffer = ByteBuffer.allocateDirect(SOCKET_BYTEBUFFER_WRITE_SIZE);

    /** The threshold represents the difference between {@link TCPForwarder#mSequenceNumberToClient}
     * and {@link TCPForwarder#mAckNumberToServer}. When this threshold is passed, it means the
     * client is overwhelmed and may start losing data. We keep this threshold at 2 times the full
     * read size from a socket. */
    private static final int SOCKET_READ_THRESHOLD_WITHOUT_ACK = 2 * SOCKET_BYTEBUFFER_READ_SIZE;

    // Used to Read and Write to TUN.
    // Read from TUN buffer must have size larger than TUN size.
    // Write to TUN buffer can be arbitrary large (IP fragmentation will be done at the lower layer automatically
    private static ByteBuffer mWriteTunBuffer = ByteBuffer.allocateDirect(SOCKET_BYTEBUFFER_READ_SIZE +
            IpDatagram.TCP_HEADER_DEFAULT_LENGTH +
            IpDatagram.IP_HEADER_DEFAULT_LENGTH);

    // Tun Interface
    static TunNativeInterface mTunInterfaceJni;

    // Single UDP Channel that take care of all UDP traffic
    private static DatagramChannel mUDPSocketChannel;

    // Used for IP fragmentation Id
    static short mIpIdentification;

    // This queue stores packets read from TUN. It is populated by an external thread that reads data from TUN.
    private static LinkedBlockingQueue<byte[]> mReadFromTunQueue = new LinkedBlockingQueue<byte[]>();

    // Map a channel to its outgoing buffer
    static final Map<Channel, LinkedList<DataWriteToNet>> mWriteToNetMap = new HashMap<Channel, LinkedList<DataWriteToNet>>();
    // List of Channel that needs to update InterestOps
    static final LinkedList<ChangeRequest> mChangeRequestQueue = new LinkedList<ChangeRequest>();
    // Map a SocketChannel to its TCPForwarder
    static final Map<SocketChannel, TCPForwarder> mSocketChannelToForwarderMap = new ConcurrentHashMap<SocketChannel, TCPForwarder>();

    // Use to map a destination tuple (IP,port) to a source tuple (IP,port)
    // This map can be used to translate the received udp packet (updating the target tuple of the received packet)
    final static Map<Tuple, Tuple> mActiveUDPConnectionMap = new ConcurrentHashMap<>();

    /** DNS Caching map */
    protected final static Map<String, String> mDNScache = new  ConcurrentHashMap<>();

    /** Set of active TCPForwarders, mapped by source port */
    public final static Map<Integer, TCPForwarder> mActiveTCPForwarderMap = new ConcurrentHashMap<>();

    /** Set of {@link edu.uci.calit2.antmonitor.lib.util.TCPReassemblyInfo}, mapped by source port */
    final static Map<Integer, TCPReassemblyInfo> mTCPReassemblyMap = new HashMap<>();

    // The single main Selector that poll all sockets
    static Selector mSocketSelector;

    // This map keep track of active threads to clean them up when shutting down
    static final ConcurrentMap<Long, Thread> mActiveThreads = new ConcurrentHashMap<>();

    /** Queue to which put packets on for off-line logging of incoming data */
    private static PacketLogQueue mIncPacketQueue;

    /** Queue to which put packets on for off-line logging of outgoing data */
    private static PacketLogQueue mOutPacketQueue;

    /** Filter that either allows or denies outgoing packets */
    public static OutPacketFilter mOutFilter;

    /** Filter that either allows or denies incoming packets */
    public static IncPacketFilter mIncFilter;

    // The runnable of the mSelectorNetIOThread.
    // It polls all the non-blocking both (single) UDP and TCP sockets for read or write.
    // At the beginning of the loop, it updates the InterestSet (READ or WRITE)
    // if there is request (made by mWriteToNetThread)
    private static Runnable mSelectorNetIO = new Runnable() {

        private boolean okToWrite(SelectionKey k, Channel channel) {
            if (mWriteToNetMap.get(channel) != null &&
                    mWriteToNetMap.get(channel).size() <= 0) {
                return false;
            }

            return true;
        }

        public void run() {
            android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_URGENT_DISPLAY);
            while (!Thread.currentThread().isInterrupted()) {

                // For a channel, sending data is prioritized over reading data
                synchronized(mChangeRequestQueue) {
                    Iterator it = mChangeRequestQueue.iterator();
                    while (it.hasNext()) {
                        ChangeRequest request = (ChangeRequest) it.next();
                        int selectionKey = request.mSelectionKey;
                        Channel channel = request.mChannel;
                        Object attachment = request.mAttachment;

                        if (channel instanceof DatagramChannel) {
                            DatagramChannel dChannel = (DatagramChannel) channel;
                            try {

                                it.remove();
                                if (!okToWrite(dChannel.keyFor(mSocketSelector), dChannel))
                                    continue;

                                dChannel.register(mSocketSelector,  selectionKey, attachment);
                            } catch (Exception e) {
                                Logg.e(TAG, "Exception when changing UDP selection key to " +
                                        selectionKey, e);
                            }
                        } else if (channel instanceof SocketChannel) {
                            SocketChannel sChannel = (SocketChannel) channel;
                            try {

                                it.remove();
                                if (!okToWrite(sChannel.keyFor(mSocketSelector), sChannel))
                                    continue;

                                //TCPForwarder forwarder = mSocketChannelToForwarderMap.get(sChannel);
                                //Logg.d(TAG, forwarder + " Registered OP_WRITE " + selectionKey);
                                if (sChannel.isOpen()) {
                                    sChannel.register(mSocketSelector, selectionKey, attachment);
                                }
                            } catch (Exception e) { //TODO: do anything upon ClosedChannelException ?
                                TCPForwarder forwarder = mSocketChannelToForwarderMap.get(sChannel);
                                Logg.e(TAG, forwarder + " Exception when changing TCP selection key to " + selectionKey);
                                Logg.e(TAG, e.getMessage(), e);
                            }
                        }
                    } // end for looping over all ChangeRequest
                }

                // Select sockets
                try {
                    mSocketSelector.select();
                } catch (CancelledKeyException ce) {
                    // Don't reveal too much about our code with this log:
                    Log.w(TAG, "Select WARNING: cancelled exception.");

                    // One of the selected keys got cancelled, although this should not happen
                    // See bug report: https://community.oracle.com/thread/1831688
                    // Hopefully it is safe to continue selecting
                    // If this solution doesn't work, we can re-connect (as below)
                    continue;
                } catch (Exception e) {
                    Log.w(TAG, "Select WARNING: " + e.getMessage(), e);

                    // This will attempt to teardown and then reconnect
                    mService.onTunnelError();
                    break;
                }

                // Iterate over all ready sockets and perform read or write
                Iterator<SelectionKey> selectedKeys = mSocketSelector.selectedKeys().iterator();
                while (selectedKeys.hasNext()) {
                    SelectionKey key = (SelectionKey) selectedKeys.next();
                    selectedKeys.remove();

                    try {
                        if (key.isValid() && key.isReadable()) {
                            readFromChannel(key);
                        } else if (key.isValid() && key.isWritable()) {
                            writeToChannel(key);
                        } else if (key.isValid() && key.isConnectable()) {
                            initializeTCPForwarder(key);
                        }
                    } catch (CancelledKeyException e) {
                        //TODO: CancelledKeyException: do anything to close?
                        Logg.e(TAG, e.getMessage(), e);
                    }
                }
            } // End main while loop
            mActiveThreads.remove(Thread.currentThread().getId());
        }
    }; // end mSelectorNetIO Runnable

    /**
     * Call this to initialize the TCP forwarder after the socket finished its connection
     * @param key
     */
    private static void initializeTCPForwarder(SelectionKey key) {

        SocketChannel channel =  (SocketChannel) key.channel();

        try {
            if (!channel.finishConnect()) {
                Logg.e(TAG, mSocketChannelToForwarderMap.get(channel) + " did not finish connect!");
                return;
            }
        } catch (Exception e) {
            Logg.e(TAG,  mSocketChannelToForwarderMap.get(channel) +
                    " Exception while checking if a TCP Channel Finished its connection!");
            return;
        }

        TCPForwarder forwarder = mSocketChannelToForwarderMap.get(channel);

//		Logg.e(TAG, "Initializing TCP Forwarder: " + forwarder);
//		Logg.e(TAG, "Key interest: " + key.interestOps());
//		Logg.e(TAG, "Attachment: " + key.attachment());

        if (forwarder != null) {
            synchronized(forwarder) {
                byte[] synAckPacketToClient = (byte[]) key.attachment();
                writeDirectToTun(synAckPacketToClient);
                //Logg.d(TAG, forwarder + " Sent SYN-ACK. Updating from " + forwarder.mServerState + " to SYN_RECEIVED");
                forwarder.mSequenceNumberToClient++;
                forwarder.mServerState = TCPState.SYN_RECEIVED;

                // At this point, new TCP connection is established:
                mOutFilter.onTCPConnectionOpened(forwarder.mServerIP.toString().substring(1),
                        forwarder.mSrc.mPort, forwarder.mDst.mPort);

                // De-register OP_CONNECT op, as this may cause the selector to return w/o keys:
                // http://stackoverflow.com/questions/16386342/android-selector-select-returns-0-immediately
                // When the client is ready to write, we will register a WRITE
                try {
                    channel.register(mSocketSelector, OP_NONE); // 0 for no interest ops
                } catch (ClosedChannelException e) {
                    Logg.e(TAG, forwarder + " channel closed while un-registering OP_CONNECT!");
                    mForwarderBacklogHandler.removeCallbacks(forwarder.mSendFinToClient);
                    mForwarderBacklogHandler.postDelayed(forwarder.mSendFinToClient, TCPForwarder.DELAY_SEND_FIN_TO_CLIENT);
                }
            }
        }

    }

    /**
     * Perform a read from a readable socket channel
     * @param key Contains ready channel
     */
    private static void readFromChannel(SelectionKey key) {
        mReadSocketBuffer.clear();

        if (key.channel() instanceof DatagramChannel) {
            // Read from a DatagramChannel, perform translation, queue the translated UDP packet to be written back to TUN
            readFromDatagramChannel(key);
        } else if (key.channel() instanceof SocketChannel) {
            // Read from a SocketChannel, queue the data TCP packet to be written back to TUN
            readFromSocketChannel(key);
        }
    } // End ReadChannel

    /**
     * Read from a DatagramChannel, perform translation, queue the translated UDP packet to be written back to TUN
     * @param key
     */
    private static void readFromDatagramChannel(SelectionKey key) {
        DatagramChannel channel = (DatagramChannel) key.channel();

        InetSocketAddress remoteAddress = null;
        try {
            remoteAddress = (InetSocketAddress) channel.receive(mReadSocketBuffer); // Need to use receive here instead of read (read is for connected channel)
        } catch (IOException e) {
            Logg.e(TAG, "Exception when reading a UDP channel:" + e.getMessage());
            return;
        }

        if (remoteAddress != null) {
            int bytesRead = mReadSocketBuffer.position();
            // Logg.i(TAG, "Read " + bytesRead + " from UDP " + remoteAddress);
            mReadSocketBuffer.flip();
/*            if (!mIncFilter.acceptIPDatagram(mReadSocketBuffer))
                return;

            // Just in case filter modified the buffer position, etc, set it back:
            mReadSocketBuffer.position(0);
            mReadSocketBuffer.limit(bytesRead);*/

            byte[] packetData = new byte[bytesRead];
            if (mReadSocketBuffer.hasArray()) {
                System.arraycopy(mReadSocketBuffer.array(), mReadSocketBuffer.arrayOffset(), packetData, 0, bytesRead);
            } else {
                mReadSocketBuffer.get(packetData, 0, bytesRead);
            }

            int srcPort = remoteAddress.getPort();
            byte[] srcIpArray = remoteAddress.getAddress().getAddress();
            int srcIp = IpDatagram.convertIPv4IPArrayToInt(srcIpArray);

            Tuple source;
            if (srcPort == IpDatagram.DNSPort) {
                int txid = UDPPacket.extractUDPv4Txid(packetData);
                source = new Tuple(srcIp, srcIpArray, txid);

                if (ForwarderManager.KEEP_DNS_CACHE) {
                    UDPPacket.mapIPtoHostName(mDNScache, packetData);
                }

            } else
                source = new Tuple(srcIp, srcIpArray, srcPort);

            Tuple activeUDP = mActiveUDPConnectionMap.get(source);
            if (activeUDP != null ||
                    // If no active connection, check if this is a broadcast response:
                    (activeUDP = mActiveUDPConnectionMap.get(
                            new VPNUtils.Tuple(VPNUtils.BROADCAST_IP_INT,
                                    VPNUtils.BROADCAST_IP_ARRAY, srcPort))) != null) {
                int dstPort = activeUDP.mPort;
                byte[] dstIpArray = activeUDP.mIpArray;
                byte[] packetToWrite = constructUdpIpPacket(packetData,
                        srcPort, srcIpArray, dstPort, dstIpArray);

                writeDirectToTun(packetToWrite);
            } else {
                Logg.e(TAG, "Received UDP packet from an unknown host: " + srcIp + ":" + srcPort);
            }
        } else {
            Logg.e(TAG, "Read 0 bytes from the UDP channel");
        }
        // End the case of reading from UDP SocketChannel
        return;
    }

    /**
     * Read from a SocketChannel, queue the data TCP packet to be written back to TUN
     * @param key
     */
    private static void readFromSocketChannel(SelectionKey key) {
        SocketChannel channel = (SocketChannel) key.channel();
        TCPForwarder forwarder = mSocketChannelToForwarderMap.get(channel);

        // Sanity check
        if (forwarder == null) {
            return;
        }

        // TODO: we may need to keep track of window size to do this more correctly
        // Client is now overwhelmed. We need to switch to WRITE mode and let the client catch up with sending ACKs
/*        if (forwarder.mSequenceNumberToClient - forwarder.mAckNumberToServer > SOCKET_READ_THRESHOLD_WITHOUT_ACK && channel.isOpen()) {
            Logg.d(TAG, forwarder + ": deregister: seqNum" + forwarder.mSequenceNumberToClient + ", ackNumber: " + forwarder.mAckNumberToServer + " , diff: " + (forwarder.mSequenceNumberToClient - forwarder.mAckNumberToServer));
            try {
                channel.register(mSocketSelector, OP_NONE);
            } catch (ClosedChannelException e) {
                Logg.e(TAG, forwarder + " Closed channel exception: " + e.getMessage(), e);
            }
            return;
        }*/


        int bytesRead = 0;
        try {
            bytesRead = channel.read(mReadSocketBuffer);
        } catch(IOException e) {
            Logg.e(TAG, "Exception while reading from TCP socket. Sending FIN to client: " + e.getMessage());
            try {
                key.cancel();
                channel.close();
            } catch(Exception e1) {
                Logg.e(TAG, "Exception closing TCP SocketChannel: " + e1.getMessage());
            }
            synchronized(forwarder) {
                //TODO: perhaps only do this if not in TIME_WAIT/CLOSING, but this seems to never happen
                mForwarderBacklogHandler.removeCallbacks(forwarder.mSendFinToClient);
                mForwarderBacklogHandler.postDelayed(forwarder.mSendFinToClient, TCPForwarder.DELAY_SEND_FIN_TO_CLIENT);
            }
            return;
        }

        if (bytesRead > 0) {
             //Logg.i(TAG, forwarder + " Bytes read from server: " + bytesRead);

            // TODO: ensure no duplicates with SSL filter
            // Set buffer for proper processing by filter
/*            mReadSocketBuffer.position(0);
            mReadSocketBuffer.limit(bytesRead);
            if (!mIncFilter.acceptIPDatagram(mReadSocketBuffer))
                return;*/

            // Forward data read to the client
            synchronized(forwarder) {
                byte[] packetToClient = forwarder.constructTcpIpPacketToClient(false, true, false,
                        false, mReadSocketBuffer.array(), mReadSocketBuffer.arrayOffset(), bytesRead);

                writeDirectToTun(packetToClient);
                forwarder.mSequenceNumberToClient += bytesRead;
            }
        } else if (bytesRead == -1) {
            Logg.e(TAG, forwarder + " Bytes read from server = -1. Sending FIN to client");
/*            if (forwarder.mServerState != TCPState.ESTABLISHED && forwarder.mServerState != TCPState.FIN_WAIT_1 &&
                    forwarder.mServerState != TCPState.CLOSE_WAIT) {
                Logg.e(TAG, forwarder + " is NOT sending Fin. state = " + forwarder.mServerState);
                return;
            }*/
            try {
                key.cancel();
                channel.close();
            } catch(Exception e1) {
                Logg.e(TAG, "Exception closing TCP Read Socket 1: " + e1.getMessage());
            }
            synchronized(forwarder) {
                mForwarderBacklogHandler.removeCallbacks(forwarder.mSendFinToClient);
                mForwarderBacklogHandler.postDelayed(forwarder.mSendFinToClient, TCPForwarder.DELAY_SEND_FIN_TO_CLIENT);
            }
            return;
        }
    }

    /**
     * Construct a UDP packet to write back to TUN.
     * @param packetData
     * @param srcPort
     * @param srcIpArray
     * @param dstPort
     * @param dstIpArray
     * @return
     */
    static byte[] constructUdpIpPacket(byte[] packetData, int srcPort,
                                               byte[] srcIpArray, int dstPort, byte[] dstIpArray) {
        // Reconstruct UDP header, then IP header, then inject this to TUN interface
        // 20 + 8 + data = 44 + data
        byte[] packetToWrite = new byte[IpDatagram.IP_HEADER_DEFAULT_LENGTH  +
                IpDatagram.UDP_HEADER_DEFAULT_LENGTH +
                packetData.length];

        // Last bytes come the data
        System.arraycopy(packetData, 0, packetToWrite, IpDatagram.IP_HEADER_DEFAULT_LENGTH  + IpDatagram.UDP_HEADER_DEFAULT_LENGTH , packetData.length);

        // First 20 bytes are IP header
        // First byte: Version 4, IP Header Len = 5: 0b01000101
        packetToWrite[0] = 0b01000101;

        // Second byte: Differentiated Services: not used

        // 3rd and 4th Byte is total length
        int totalLen = IpDatagram.IP_HEADER_DEFAULT_LENGTH  + IpDatagram.UDP_HEADER_DEFAULT_LENGTH + packetData.length;
        packetToWrite[2] = (byte) (totalLen >> 8);
        packetToWrite[3] = (byte) (totalLen);

        // 5th and 6th Byte is Identification for fragmentation:
        mIpIdentification++;
        if (mIpIdentification == Short.MAX_VALUE) {
            mIpIdentification = 0;
        }
        packetToWrite[4] = (byte) (mIpIdentification >> 8);
        packetToWrite[5] = (byte) (mIpIdentification);

        // 7th and 8th are Flags and Fragment offset: not used

        // 9th is TTL. Set to 20
        packetToWrite[8] = (byte) 20;

        // 10th is Protocol: UDP = 17
        packetToWrite[9] = (byte) 17;

        // 13, 14, 15, 16 are Source IP
        packetToWrite[12] = srcIpArray[0];
        packetToWrite[13] = srcIpArray[1];
        packetToWrite[14] = srcIpArray[2];
        packetToWrite[15] = srcIpArray[3];

        // 17, 18, 19, 20 are Dest IP
        packetToWrite[16] = dstIpArray[0];
        packetToWrite[17] = dstIpArray[1];
        packetToWrite[18] = dstIpArray[2];
        packetToWrite[19] = dstIpArray[3];

        // Next 8 bytes are UDP header
        // Source port
        packetToWrite[IpDatagram.IP_HEADER_DEFAULT_LENGTH] = (byte) (srcPort >> 8);
        packetToWrite[IpDatagram.IP_HEADER_DEFAULT_LENGTH+1] = (byte) (srcPort);
        // Destination port
        packetToWrite[IpDatagram.IP_HEADER_DEFAULT_LENGTH+2] = (byte) (dstPort >> 8);
        packetToWrite[IpDatagram.IP_HEADER_DEFAULT_LENGTH+3] = (byte) (dstPort);
        // Length field
        int len = IpDatagram.UDP_HEADER_DEFAULT_LENGTH + packetData.length;
        packetToWrite[IpDatagram.IP_HEADER_DEFAULT_LENGTH+4] = (byte) (len >> 8);
        packetToWrite[IpDatagram.IP_HEADER_DEFAULT_LENGTH+5] = (byte) (len);
        // Checksum field: clear to 0 to disable
        packetToWrite[IpDatagram.IP_HEADER_DEFAULT_LENGTH+6] = (byte) 0;
        packetToWrite[IpDatagram.IP_HEADER_DEFAULT_LENGTH+7] = (byte) 0;

        // 11th and 12th are header IP Check sum
        long checkSum = IpDatagram.calculateIPv4Checksum(packetToWrite, 0, IpDatagram.IP_HEADER_DEFAULT_LENGTH);
        packetToWrite[10] = (byte) (checkSum >> 8);
        packetToWrite[11] = (byte) (checkSum);

//		String res = "";
//		for (int i=0; i<packetToWrite.length; i++) {
//			res += packetToWrite[i] + " ";
//		}
//		Logg.e(TAG, "Constructed packet: " + res);

        return packetToWrite;
    } // End constructUDPPacket


    /**
     * Perform a write to a writable socket channel
     */
    private static void writeToChannel(SelectionKey key) {
        mWriteSocketBuffer.clear();

        if (key.channel() instanceof DatagramChannel) {
            synchronized(mWriteToNetMap) {
                writeToDatagramChannel(key);
            }
        } else if (key.channel() instanceof SocketChannel) {
            boolean result;
            synchronized(mWriteToNetMap) {
                result = writeToSocketChannel(key);
            }

            // If an exception occurred, send FIN to client
            if (!result) {
                TCPForwarder forwarder = mSocketChannelToForwarderMap.get(key.channel());
                if (forwarder != null) {
                    synchronized (forwarder) {
                        mForwarderBacklogHandler.removeCallbacks(forwarder.mSendFinToClient);
                        mForwarderBacklogHandler.postDelayed(forwarder.mSendFinToClient, 0);
                    }
                } else
                    Logg.e(TAG, "forwarder is null, cannot send FIN!");
            }
        }
    }

    /**
     * Write to a writable DatagramChannel
     * @param key
     */
    private static void writeToDatagramChannel(SelectionKey key) {
        DatagramChannel channel = (DatagramChannel) key.channel();
        LinkedList<DataWriteToNet> dataList = mWriteToNetMap.get(channel);

        // Write one UDP datagram at a time, then return to the main select loop
        if (dataList != null && dataList.size() > 0) {
            DataWriteToNet writeData = dataList.pollFirst();
            SocketAddress remoteAddress = writeData.mRemoteAddress;
            byte[] data = writeData.mData;
            int offset = writeData.mDataOffset;
            int len = writeData.mDataLen;

            if (mWriteSocketBuffer.hasArray()) {
                System.arraycopy(data, offset, mWriteSocketBuffer.array(), mWriteSocketBuffer.arrayOffset(), len);
                mWriteSocketBuffer.position(0);
                mWriteSocketBuffer.limit(len);
            } else {
                mWriteSocketBuffer.put(data, offset, len);
                mWriteSocketBuffer.flip();
            }

            try {
                // Socket not connected, can send with dest ip
                channel.send(mWriteSocketBuffer, remoteAddress);
            } catch (IOException e) {
                Logg.e(TAG, "Exception while writing to UDP channel: " + e.getMessage() +
                " addr = " + remoteAddress);
            }
            // Logg.i(TAG, "Sent " + data.length + " to UDP " + remoteAddress);
        }

        // Restore READ interest if all data are written
        try {
            if (dataList.size() == 0) {
                channel.register(mSocketSelector, SelectionKey.OP_READ);
            }
        } catch (ClosedChannelException e) {
            Logg.e(TAG, "Exception while restoring from WRITE to READ interest set for the UDP Channel: " + e.getMessage());
        }
    }


    /**
     * Write to a writable SocketChannel
     * @param key
     * @return {@code true} if everything went well, {@code false} if an exception occured
     */
    private static boolean writeToSocketChannel(SelectionKey key) {
        SocketChannel channel = (SocketChannel) key.channel();
        LinkedList<DataWriteToNet> dataList = mWriteToNetMap.get(channel);
        TCPForwarder forwarder = mSocketChannelToForwarderMap.get(channel);

        // Sanity check
        if (dataList == null || dataList.size() == 0 || forwarder == null) {
            // Restore READ interest if all data are written
            // Restore only if READ has not passed threshold. We need to let the client keep up with ACKs.
            try {
                // Restore only if READ has not passed threshold. We need to let the client keep up with ACKs.
                if (forwarder.mSequenceNumberToClient - forwarder.mAckNumberToServer < SOCKET_READ_THRESHOLD_WITHOUT_ACK && channel.isOpen()) {
                    Logg.d(TAG, forwarder + ": Registered to Read 1: seqNum" + forwarder.mSequenceNumberToClient + ", ackNumber: " + forwarder.mAckNumberToServer + " , diff: " + (forwarder.mSequenceNumberToClient - forwarder.mAckNumberToServer));
                    channel.register(mSocketSelector, SelectionKey.OP_READ);
                }
            } catch (Exception e) {
                Logg.e(TAG, forwarder +
                        " Exception while restoring from WRITE to READ interest set for TCP Channel." +
                        " Sending FIN to client: " + e.getMessage());
                return false;
            }

            return true;
        }

        // Write one data token at a time, write as much as we could, then loop back to the Selector loop
        while (dataList.size() > 0) {
            mWriteSocketBuffer.clear();
            long ackNum = -1;

            DataWriteToNet current = dataList.peekFirst();
            // Note that mDataLen is less than TUN size;
            if (current.mDataLen <= mWriteSocketBuffer.remaining()) {
                dataList.poll();

                ackNum = current.mAckNum;

                if (channel.socket().getPort() == TLSProxyServer.port) {
                    // We are only going to touch elements of forwarder that are read/written by
                    // this thread and the TLSProxyForwarder thread. Therefore, there is no
                    // need to synchronize on forwarder (that would cause deadlock with Network IO
                    // thread - see TCPForwarder line ~546 - forwardData)
                    synchronized (mTCPReassemblyMap) {
                        TCPReassemblyInfo tcpInfo = mTCPReassemblyMap.get(forwarder.mSrc.mPort);
                        // First TCP segment, memorize its SEQ+ACK
                        if (tcpInfo == null) {
                            tcpInfo = new TCPReassemblyInfo(
                                    IpDatagram.readDestinationIP(current.mData),
                                    forwarder.mSrc.mPort, forwarder.mDst.mPort,
                                    TCPPacket.extractTCPv4AckNumber(current.mData),
                                    TCPPacket.extractTCPv4SequenceNumber(current.mData),
                                    current.mDataLen);
                            mTCPReassemblyMap.put(forwarder.mSrc.mPort, tcpInfo);
                        } else {
                            // Subsequent TCP segment, add up data length:
                            tcpInfo.addToDataLen(current.mDataLen);
                        }
                    }
                }

                if (mWriteSocketBuffer.hasArray()) {
                    System.arraycopy(current.mData, current.mDataOffset,
                            mWriteSocketBuffer.array(), mWriteSocketBuffer.arrayOffset() + mWriteSocketBuffer.position(), current.mDataLen);
                    mWriteSocketBuffer.position(mWriteSocketBuffer.position() + current.mDataLen);
                } else {
                    mWriteSocketBuffer.put(current.mData, current.mDataOffset, current.mDataLen);
                }
            }

            mWriteSocketBuffer.flip();

            try {
                // int bytesWritten = 0;
                // bytesWritten = channel.write(mWriteBuffer);
                // Logg.i(TAG, "Bytes written to server " + bytesWritten);
                channel.write(mWriteSocketBuffer);
            } catch (Exception e) {
                Logg.e(TAG, "Exception while forwarding data to server. Sending FIN to client:" + e.getMessage());

                // Ack data and return, perhaps ack not needed even
                /*synchronized(forwarder) {
                    mForwarderBacklogHandler.removeCallbacks(forwarder.mSendFinToClient);
                    mForwarderBacklogHandler.postDelayed(forwarder.mSendFinToClient, 0);
                }*/
                return false;
            }

            if (ackNum > 0) {
                // Perform this on a separate thread not to block IO thread
                final TCPForwarder finalForwarder = forwarder;
                final long finalAck = ackNum;
                mForwarderBacklogHandler.post(new Runnable() {
                    public void run() {
                        finalForwarder.mAckNumberToClient = finalAck;
                        byte[] packetToClient = finalForwarder.constructTcpIpPacketToClient(false, true, false, false, null, 0, 0);
                        writeDirectToTun(packetToClient);
                    }
                });

            }

            // Put the remaining data back
            if (mWriteSocketBuffer.remaining() > 0) {
                byte[] remainingData = new byte[mWriteSocketBuffer.remaining()];

                if (mWriteSocketBuffer.hasArray()) {
                    System.arraycopy(mWriteSocketBuffer.array(), mWriteSocketBuffer.arrayOffset() + mWriteSocketBuffer.position(),
                            remainingData, 0, mWriteSocketBuffer.remaining());
                } else {
                    mWriteSocketBuffer.get(remainingData);
                }

                DataWriteToNet dataWriteToNet = new DataWriteToNet(null, -1, remainingData, 0, remainingData.length);
                dataList.offerFirst(dataWriteToNet);
                break;
            }
        }

        // Restore READ interest if all data are written
        try {
            if (dataList.size() == 0 ) {
                // Restore only if READ has not passed threshold. We need to let the client keep up with ACKs.
                if (forwarder.mSequenceNumberToClient - forwarder.mAckNumberToServer < SOCKET_READ_THRESHOLD_WITHOUT_ACK && channel.isOpen()) {
                    //Logg.d(TAG, forwarder + ": Registered to Read 2: seqNum" + forwarder.mSequenceNumberToClient + ", ackNumber: " + forwarder.mAckNumberToServer + " , diff: " + (forwarder.mSequenceNumberToClient - forwarder.mAckNumberToServer));
                    channel.register(mSocketSelector, SelectionKey.OP_READ);
                } else {
                    Logg.d(TAG, forwarder + ": Client overloaded. not switching to OP_READ: seqNum" + forwarder.mSequenceNumberToClient + ", ackNumber: " + forwarder.mAckNumberToServer + " , diff: " + (forwarder.mSequenceNumberToClient - forwarder.mAckNumberToServer));
                }
            }
        } catch (Exception e) {
            Logg.e(TAG, forwarder +
                    " Exception while restoring from WRITE to READ interest set for TCP Channel." +
                    " Sending FIN to client: " + e.getMessage());
            return false;
        }

        return true;
    }

    private final Runnable mWriteToNet;

    /**
     * Private constructor to support singleton pattern
     */
    private ForwarderManager() {
        mWriteToNet = new TUNReader(this);
    }

    public static ForwarderManager getInstance(VpnClient service,
                                               PacketLogQueue incPacketQueue,
                                               PacketLogQueue outPacketQueue,
                                               IncPacketFilter incFilter, OutPacketFilter outFilter) {
        mIncPacketQueue = incPacketQueue;
        mOutPacketQueue = outPacketQueue;
        mIncFilter = incFilter;
        mOutFilter = outFilter;
        mService = service;

        return mSingleton;
    }

    /**
     * Starts the ForwarderManager.
     * @param fileDes - the File Descriptor of an established TUN interface
     */
    public synchronized void start(ParcelFileDescriptor fileDes) {
        // Stop all previous threads
        if (mForwarderBacklogHandlerThread != null) {
            mForwarderBacklogHandlerThread.quit();
        }

        if (mTLSHandlerThread != null) {
            mTLSHandlerThread.quit();
        }

        if (mSocketSelector != null) {
            mSocketSelector.wakeup();
        }
        for (Thread thread : mActiveThreads.values() ) {
            thread.interrupt();
        }

        // Close previous streams
        if (mTunInterfaceJni != null) {
            // TODO: correct replacement?
            //mTunInterfaceJni.close();
        }

        // Start anew
        mTunInterfaceJni = TunNativeInterface.getTunPollJni(fileDes.getFd());

        // Initialize data and start threads
        mReadFromTunQueue.clear();
        mWriteToNetMap.clear();
        mChangeRequestQueue.clear();
        mSocketChannelToForwarderMap.clear();
        mActiveUDPConnectionMap.clear();
        mIpIdentification = 0;
        try {
            mSocketSelector = SelectorProvider.provider().openSelector();
        } catch(IOException e) {
            Logg.e(TAG, "Exception initializing the socket selector: " + e.getMessage());
        }
        initializeUDPSocketChannel(mService);

        mForwarderBacklogHandlerThread = new HandlerThread("Forwarder backlog handler thread");
        mActiveThreads.put(mForwarderBacklogHandlerThread.getId(), mForwarderBacklogHandlerThread);
        mForwarderBacklogHandlerThread.start();
        mForwarderBacklogHandler = new Handler(mForwarderBacklogHandlerThread.getLooper());

        mTLSHandlerThread = new HandlerThread("TLS Handler Thread");
        mActiveThreads.put(mTLSHandlerThread.getId(), mTLSHandlerThread);
        mTLSHandlerThread.start();
        mTLSHandler = new Handler(mTLSHandlerThread.getLooper());

        mSelectorNetIOThread = new Thread(mSelectorNetIO);
        mSelectorNetIOThread.setName("Selector Network IO Thread");
        mActiveThreads.put(mSelectorNetIOThread.getId(), mSelectorNetIOThread);
        mSelectorNetIOThread.start();

        mWriteToNetThread = new Thread(mWriteToNet);
        mWriteToNetThread.setName("Write-to-NET Worker Thread");
        mActiveThreads.put(mWriteToNetThread.getId(), mWriteToNetThread);
        mWriteToNetThread.start();

        isRunning = true;
        Log.i(TAG, "ForwarderManager Started.");
    }

    /**
     * Initialize and register UDP Socket Channel
     * @param service
     */
    private static void initializeUDPSocketChannel(VpnService service) {
        try {
            if (mUDPSocketChannel != null) {
                mUDPSocketChannel.close();
            }

            mUDPSocketChannel = DatagramChannel.open();
            mUDPSocketChannel.configureBlocking(false);
            DatagramSocket socket = mUDPSocketChannel.socket();
            socket.bind(null);
            socket.setBroadcast(true);
            service.protect(socket);
        } catch (Exception e) {
            Logg.e(TAG, "Exception when Initializing the protected UDP Socket Channel");
        }
    }

    /**
     * Stop all threads. Close all files and channels.
     */
    public synchronized void shutdown() {
        // Stop all threads
        if (mForwarderBacklogHandlerThread != null) {
            mForwarderBacklogHandlerThread.quit();
        }
        if (mSocketSelector != null) {
            mSocketSelector.wakeup();
        }
        for (Thread thread : mActiveThreads.values() ) {
            thread.interrupt();
        }

        // Update state variable to indicate we are no longer running
        isRunning = false;

        if (mUDPSocketChannel != null) {
            try {
                mUDPSocketChannel.close();
            } catch (IOException e) {
                Logg.e(TAG, "Exception when shutting down the UDP DatagramChannel: " + e.getMessage());
            }
        }

        teardownConnections();
    }

    /** Closes all open TCP channels and clears all maps of connections */
    protected synchronized void teardownConnections() {
        // Close all TCP channels
        for (SocketChannel channel : mSocketChannelToForwarderMap.keySet()) {
            try {
                channel.close();
            } catch (IOException e) {
                Logg.e(TAG, "Exception when shutting down a TCP SocketChannel: " + e.getMessage());
            }
        }

        // Clear maps to remove references to Forwarders so that they are garbage collected
        mActiveTCPForwarderMap.clear();
        mSocketChannelToForwarderMap.clear();
        mWriteToNetMap.clear();

        Logg.i(TAG, "UDP Connection Manager shutdown complete.");
    }

    /**
     * Write a constructed packet directly to TUN
     */
    static void writeDirectToTun(byte[] packet) {
        int packetOffset = 0;
        int packetLength = packet.length;

        synchronized(mWriteTunBuffer) {
            mWriteTunBuffer.clear();

            // Sanity check
            if (packet.length > mWriteTunBuffer.capacity()) {
                Logg.e(TAG, "Packet to write to TUN is bigger than Write TUN Buffer");
                return;
            }

            if (mWriteTunBuffer.hasArray()) {
                System.arraycopy(packet, packetOffset, mWriteTunBuffer.array(), mWriteTunBuffer.arrayOffset(), packetLength);
                mWriteTunBuffer.position(0);
                mWriteTunBuffer.limit(packetLength);
            } else {
                mWriteTunBuffer.put(packet, packetOffset, packetLength);
                mWriteTunBuffer.flip();
            }

            PacketAnnotation packetAnnot = mIncFilter.acceptIPDatagram(mWriteTunBuffer);
            if (!packetAnnot.isAllowed())
                return;

            if (mIncPacketQueue != null)
                mIncPacketQueue.put(new PacketDumpInfo(packet, packetAnnot));

            // Reset back for writing
            mWriteTunBuffer.position(0);
            mWriteTunBuffer.limit(packetLength);

            mTunInterfaceJni.write(mWriteTunBuffer, packetLength);
        }
    }

    /**
     * Process given packet and queue it for writing to the network
     * @param packet the packet that was read from TUN and needs to be written to the network
     * @param packetAnnot packet annotation created by a {@link PacketFilter}
     */
    void processTUNReadData(byte[] packet, PacketAnnotation packetAnnot) {
        int ipVer = IpDatagram.extractIPVersion(packet);
        if (ipVer == IpDatagram.IPV4) {

            // TODO: room for OPT here as we extract srcPort, etc. multiple times
            // Copy packet for logging
            if (mOutPacketQueue != null)
                mOutPacketQueue.put(new PacketDumpInfo(packet, packetAnnot));

            byte protocol = IpDatagram.readProtocol(packet);
            int dstPort = IpDatagram.readDestinationPort(packet);
            int dstIp = IpDatagram.extractIPv4DestinationIP(packet);
            byte[] dstIpArray = IpDatagram.extractIPv4DestinationIPArray(packet);
            int srcPort = IpDatagram.readSourcePort(packet);
            int srcIp = IpDatagram.extractIPv4SourceIP(packet);
            byte[] srcIpArray = IpDatagram.extractIPv4SourceIPArray(packet);

            // Skip non-tun traffic based on our TUN configuration (192.168.0.2)
            if (srcIpArray[0] != -64 || srcIpArray[1] != -88 || srcIpArray[2] != 0 || srcIpArray[3] != 2) {
                return;
            }

            if (protocol == IpDatagram.UDP) {
                byte[] packetData = UDPPacket.extractUDPv4Data(packet);
                VPNUtils.Tuple destination;
                // If DNS (port 53) then use TXID as key to map
                // otherwise multiple sources will map to same DNS destination!
                if (dstPort == IpDatagram.DNSPort) {
                    int txid = UDPPacket.extractUDPv4Txid(packetData);
                    destination = new VPNUtils.Tuple(dstIp, dstIpArray, txid);
                } else
                    destination = new VPNUtils.Tuple(dstIp, dstIpArray, dstPort);

                VPNUtils.Tuple source = new VPNUtils.Tuple(srcIp, srcIpArray, srcPort);
                mActiveUDPConnectionMap.put(destination, source);

                InetSocketAddress remoteAddress = null;
                try {
                    remoteAddress = new InetSocketAddress(InetAddress.getByAddress(dstIpArray), dstPort);
                } catch (Exception e) {
                    Logg.e(TAG, "Exception creating UDP remote address" + e.getMessage());
                    return;
                }

                VPNUtils.DataWriteToNet writeData = new VPNUtils.DataWriteToNet(remoteAddress, -1, packetData, 0, packetData.length);

                // Request to change channel interests and queue the data to write
                synchronized(mChangeRequestQueue) {
                    mChangeRequestQueue.offerLast(new VPNUtils.ChangeRequest(mUDPSocketChannel, SelectionKey.OP_WRITE, null));
                    synchronized(mWriteToNetMap) {
                        LinkedList<VPNUtils.DataWriteToNet> queue = mWriteToNetMap.get(mUDPSocketChannel);
                        if (queue == null) {
                            queue = new LinkedList<VPNUtils.DataWriteToNet>();
                            mWriteToNetMap.put(mUDPSocketChannel, queue);
                        }
                        queue.add(writeData);
                    }
                }
                mSocketSelector.wakeup();

            } else if (protocol == IpDatagram.TCP) {
                // If there exists a TCP forwarder for this flow, let it handle the packet.
                // If not then create one.
                VPNUtils.Tuple src = new VPNUtils.Tuple(srcIp, srcIpArray, srcPort);
                VPNUtils.Tuple dst = new VPNUtils.Tuple(dstIp, dstIpArray, dstPort);

                TCPForwarder existingForwarder = mActiveTCPForwarderMap.get(srcPort);
                if (existingForwarder != null) {
                    existingForwarder.processPacket(packet);
                } else {
                    TCPForwarder newForwarder = new TCPForwarder(src, dst);
                    mActiveTCPForwarderMap.put(srcPort, newForwarder);
                    newForwarder.processPacket(packet);
                }

            } else if (protocol == IpDatagram.ICMP) {
                // Logg.e(TAG, "Protocol = ICMP. Not supported.");
            }
        } else if (ipVer == IpDatagram.IPV6) {
            Logg.e(TAG, "IP Version 6");
            // TODO
        }
    }


    /** @return {@code true} if SSL bumping is enabled, {@code false} otherwise */
    static boolean getSSLBumpingEnabled() { return SSL_BUMPING_ENABLED; }

    /**
     * @param context used to check if certificate was installed
     * @param enabled pass {@code true} to enable SSL bumping, and
     * pass {@code false} otherwise
     * @throws IllegalStateException if certificate is not installed and {@code enabled} is
     * true
     */
    static void setSSLBumpingEnabled(Context context, boolean enabled)
            throws IllegalStateException {
        // If user wants to enable this, check if certificate was installed first
        if (enabled) {
            SharedPreferences sp = context.getSharedPreferences(TLSCertificateActivity.prefsName,
                    Context.MODE_PRIVATE);
            boolean installed = false;
            try {
                installed = TLSCertificateActivity.isCACertificateInstalled();
            } catch (Exception e) {}

            if (!installed || !sp.getBoolean(TLSCertificateActivity.certInsallPref, false))
                throw new IllegalStateException("Cannot enable SSL bumping when certificate " +
                                                "was not installed");
        }
        SSL_BUMPING_ENABLED = enabled;
    }

    boolean isRunning() { return isRunning; }
}
